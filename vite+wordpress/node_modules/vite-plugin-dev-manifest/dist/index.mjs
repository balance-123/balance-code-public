import { existsSync, mkdirSync, rmSync, writeFileSync } from 'fs';
import path from 'path';
import { normalizePath } from 'vite';
import os from 'os';

function resolveHost(host) {
  if (!host)
    return "localhost";
  if (host === true) {
    const nInterface = Object.values(os.networkInterfaces()).flatMap((nInterface2) => nInterface2 ?? []).filter(
      (detail) => detail && detail.address && (typeof detail.family === "string" && detail.family === "IPv4" || typeof detail.family === "number" && detail.family === 4)
    ).filter((detail) => {
      return detail.address !== "127.0.0.1";
    })[0];
    if (!nInterface)
      return "localhost";
    return nInterface.address;
  }
  return host;
}

const MANIFEST_NAME = "manifest.dev";
const createSimplifyPath = (root, base) => (path2) => {
  path2 = normalizePath(path2);
  if (root !== "/" && path2.startsWith(root)) {
    path2 = path2.slice(root.length);
  }
  if (path2.startsWith(base)) {
    path2 = path2.slice(base.length);
  }
  if (path2[0] === "/") {
    path2 = path2.slice(1);
  }
  return path2;
};
const plugin = ({ omitInputs = [], manifestName = MANIFEST_NAME, delay, clearOnClose = true } = {}) => ({
  name: "dev-manifest",
  enforce: "post",
  configureServer(server) {
    const { config, httpServer } = server;
    if (!config.env.DEV || !config.build.manifest) {
      return;
    }
    httpServer?.once("listening", () => {
      const { root: _root, base } = config;
      const root = normalizePath(_root);
      const protocol = config.server.https ? "https" : "http";
      const host = resolveHost(config.server.host);
      const port = config.server.port;
      const url = `${protocol}://${host}:${port}${base}`;
      const manifest = {
        url,
        inputs: {}
      };
      const inputOptions = config.build.rollupOptions?.input ?? {};
      const simplifyPath = createSimplifyPath(root, base);
      config.server.origin = `${protocol}://${host}:${port}`;
      if (typeof inputOptions === "string") {
        manifest.inputs["main"] = simplifyPath(inputOptions);
      } else if (Array.isArray(inputOptions)) {
        for (const name of inputOptions) {
          if (omitInputs.includes(name))
            continue;
          manifest.inputs[name] = simplifyPath(name);
        }
      } else {
        for (const [name, path2] of Object.entries(inputOptions)) {
          if (omitInputs.includes(name))
            continue;
          manifest.inputs[name] = simplifyPath(path2);
        }
      }
      const outputDir = path.isAbsolute(config.build.outDir) ? config.build.outDir : path.resolve(config.root, config.build.outDir);
      if (!existsSync(outputDir)) {
        mkdirSync(outputDir, { recursive: true });
      }
      const writeManifest = () => {
        writeFileSync(path.resolve(outputDir, `${manifestName}.json`), JSON.stringify(manifest, null, "	"));
      };
      if (delay !== void 0 && typeof delay === "number") {
        setTimeout(() => writeManifest(), delay);
      } else {
        writeManifest();
      }
    });
    httpServer?.once("close", () => {
      if (!clearOnClose)
        return;
      const outputDir = path.isAbsolute(config.build.outDir) ? config.build.outDir : path.resolve(config.root, config.build.outDir);
      const manifestPath = path.resolve(outputDir, `${manifestName}.json`);
      if (existsSync(manifestPath))
        rmSync(manifestPath);
    });
  }
});

export { plugin as default };
